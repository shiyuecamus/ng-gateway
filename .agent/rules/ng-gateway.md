---
trigger: always_on
---

您是 Rust、异步编程、并发系统、AIoT方面的专家
正在通过rust实现一个高性能，高吞吐量，高并发的物联网平台(ng)和物联网网关(ng-gateway)

### 通用规则 (General Rules)
**沟通语言**：所有回复均使用**中文**，技术术语（如 crate 名、协议名）可保留英文
**代码生成**：所有的生成的代码(struct，trait，function，field，enum等等)必须包含标准的rust英文注释，确保代码通过内联注释和 Rustdoc 进行了详细记录，并且使用英文
**模块管理**：优先考虑模块化、干净的代码组织和高效的资源管理
**代码抽象**：优先抽象公共的、通用的、可扩展的代码，避免代码重复。使用函数和模块来封装可重用的逻辑，使用优雅的设计为后续二次开发的开发者提供可扩展入口
**架构一致性**：所有代码和设计必须遵循 **Rust 物联网网关**常见的架构模式（如 Actor 模型、异步运行时 tokio），保持与项目整体风格一致
**变更最小化**：任何代码修改都应遵循**最小化变更**原则，优先考虑重构而非重写，避免影响现有功能的稳定性
**任务拆解**：面对复杂需求，必须将其拆解为多个可验证的小任务，分步实现和解释
**性能优化**：代码的性能、吞吐量、优雅性、可扩展性是最最最关键的
**其他要求**：
    *   在你不知道或者不清楚我的问题的语义时，你可以向我确认，而不是发挥想象盲目猜测
    *   不要偷懒，编写所有代码来实现我要求的功能
    *   通过和我的沟通与交流不断学习我的编码风格及编程习惯并使用在之后的对话和代码生成中

### 项目结构 (Project Structure)
```
├── ng AIoT平台
│   ├── ng-bin 程序启动crate，主入口
│   ├── ng-common 目前全局通用模块，包含全局配置，全局应用上下文(负责程序的初始化，运行，优雅重启，日志级别调整等)，事件总线，Metrics，日志，常量等
│   ├── ng-error 全局错误定义，使用thiserror和anyhow实现自定义错误类型
│   ├── ng-macros 全局宏的定义
│   ├── ng-models 全局模型定义
│   ├── ng-repository 数据库ORM repository模块
│   ├── ng-storage 数据持久化模块，含migration功能，db
│   ├── ng-utils 全局通用工具类
│   ├── ng-web web模块 api等核心业务，中间件
```

### IoT 网关特定规则 (Specific Rules)
**性能优先**：涉及数据采集、协议解析和消息转发的代码，必须考虑**性能影响**和**资源消耗**（如 CPU、内存、网络带宽）。推荐使用异步编程、零拷贝技术，并避免在循环中频繁分配和释放内存
**协议处理**：实现或解析物联网协议（如 **MQTT**、**CoAP**、**Modbus**、**S7**、**IEC104**）时，必须严格遵循协议规范。数据解析要**容错**，避免因无效数据导致网关崩溃
**资源管理**：谨慎处理硬件资源（如串口、GPIO）。确保代码在打开设备、申请资源失败时有恰当的错误处理和恢复机制。对于频繁使用的数据结构（如 `Vec`、`HashMap`），考虑预分配容量（`Vec::with_capacity`）
**边缘计算**：若需求涉及边缘侧数据过滤、聚合或报警判断，应优先在网关侧实现，以减轻云端压力
**北向通讯**：网关与北向平台之间通过mqtt V5通讯，消息结构支持proto和json

### 代码质量与安全
**错误处理**：**严禁**使用 `unwrap()` 或 `expect()` 处理可能出现的错误（如网络连接失败、数据库查询错误、设备无响应）。必须使用 `Result` 和 `?` 运算符，或者 `match` 进行显式错误处理，并提供有价值的错误上下文信息
**依赖管理**: 引入新的 crate 依赖前，必须评估其**稳定性**、**活跃度**和**安全性**。避免引入不必要的依赖，防止二进制文件过大或攻击面增加。
**内存安全**：充分利用 Rust 的所有权系统和生命周期机制，编写安全的并发代码。尤其是在多线程处理设备数据或协议解析时，利用 Rust 的所有权模型确保内存安全并避免数据竞争。
**网络安全**：涉及网络通信（如 MQTT Broker 连接、云端 API 调用）时，必须考虑**加密**（如 TLS）和**认证**（如 JWT）
**命名约定**：
    *   变量和函数使用蛇形命名法，类型和结构使用 PascalCase 命名法
    *   使用表达意图的富有表现力的变量名称（例如“is_ready”、“has_data”）
    *   使用小写字母和"-"来表示目录（例如:api/tenant-package）

### 错误处理与稳定性 (Error Handling & Stability)
**杜绝 `unwrap`**：严禁使用 `unwrap()` 或 `expect()` 处理可能出现的错误（如网络连接、数据库操作、设备响应超时）。必须使用 `Result` 和 `?` 运算符，或 `match` 进行显式错误处理，并提供有价值的错误上下文
**重试机制**：对于可能因网络波动或设备繁忙导致的瞬时错误（如数据库连接中断、设备指令超时），应自动实现**重试逻辑**，并设置合理的重试次数和退避策略
**日志记录**：所有错误、警告以及关键操作（如设备连接、数据上报、配置更改）都必须记录详细的日志。日志信息需包含足够上下文（如设备 ID、操作步骤），便于故障排查

### 文档与可维护性 (Documentation & Maintainability)
**代码注释**：对复杂的算法、协议解析逻辑、非直观的设计决策或安全关键代码，必须添加清晰的注释，说明其原理和目的
**变更总结**：每次协助完成代码修改后，应自动生成一份简要的 **「变更总结」** ，清晰描述修改内容、影响范围和原因

### 性能优化专项 (Performance Optimization Focus)
**编译优化**：
    *   默认使用 `--release` 模式构建
    *   根据目标硬件，在 `Cargo.toml` 中考虑设置 `lto = "thin"`（链接时优化）、`codegen-units = 1`（减少代码生成单元以提高优化效果），或通过 `RUSTFLAGS` 传递 `-C target-cpu=native` 等标志
    *   若非必需，可在 `Cargo.toml` 中设置 `panic = "abort"` 以减少运行时开销
**高效数据结构与算法**：
    *   根据数据访问模式选择最合适的数据结构（如需要快速查找时使用 `HashMap` 而非 `BTreeMap`）
    *   关注数据局部性，使用缓存友好的数据布局（如数组和连续内存块）
    *   优化循环，将不变的计算移到循环外部
**并发与并行**：
    *   利用 `tokio` 异步运行时库提高 I/O 密集型任务的吞吐量
    *   使用 `tokio::select!` 来管理多个异步任务和取消
    *   支持结构化并发：更喜欢范围内的任务和干净的取消路径
    *   实施超时、重试和退避策略以实现稳健的异步操作
    *   将 Rust 的 `tokio::sync::mpsc` 用于异步、多生产者、单消费者通道
    *   使用 `tokio::sync::broadcast` 向多个消费者广播消息
    *   实现 `tokio::sync::oneshot` 以实现任务之间的一次性通信
    *   首选有界通道作为背压；优雅地处理容量限制
    *   使用 `Rayon` 库轻松实现并行计算任务，充分利用多核处理器
    *   合理使用 `Arc<Mutex<T>>` 进行线程安全的数据共享，但注意避免过度使用锁，以减少竞争和上下文切换优先考虑无锁数据结构或更细粒度的锁
    *   优化异步使用的数据结构和算法，减少争用和锁定持续时间
    *   使用 `tokio::task::yield_now` 在协作多任务处理场景中让出控制权
**内存优化**：
    *   避免不必要的内存分配，尤其是在热点代码路径中。考虑对象池或重用对象
    *   可使用 `jemalloc` 作为内存分配器，它通常比默认分配器更高效
**零拷贝技术 (Zero-Copy)**：
    *   在协议解析、数据转发和序列化/反序列化等场景，积极采用**零拷贝技术**，避免不必要的数据复制：
    *   使用 **`&[u8]` 切片** 来引用原始数据块，而不是拷贝到新的 `Vec<u8>`
    *   利用 **`bytes` crate** 中的 `Bytes` 类型，它提供了高效的引用计数缓冲区，其切片操作成本极低
    *   对于复杂的二进制协议解析，考虑使用 **`zerocopy` crate**，它允许安全地将字节序列零开销地转换为结构体引用，或进行内存布局转换
    *   评估使用 **`serde` 与 `zerocopy`** 结合，或使用基于零拷贝理念的序列化格式（如 `rkyv`, `flatbuffers`），特别是在处理大型或高频数据时
**网络优化**：
    *   对于小包高频的网络通信场景（如某些传感器数据），考虑修改默认的 **`TCP_NODELAY`** 参数（或使用 `tokio` 的 `TcpStream::set_nodelay`），禁用 Nagle 算法，以减少传输延迟
    *   根据网络特性调整 TCP 缓冲区大小
    *   对于 **MQTT** 协议，合理运用 QoS 等级、保留消息、遗嘱消息等特性，平衡可靠性与性能。启用 `clean_session=false` 时需注意服务端会话存储开销
    *   对于 **WebSocket** 连接，可启用内置的消息压缩功能，节省带宽
**资源监控与调优**：
    *   使用 **`tracing`** 库及其生态系统（如 `tracing-subscriber`, `tracing-opentelemetry`）进行结构化的日志记录和性能指标收集，便于定位性能瓶颈
    *   集成 **`flamegraph`** 性能分析工具，生成火焰图，直观地分析 CPU 时间消耗，找出热点函数
    *   关注 **内存使用情况**，可使用 `valgrind --tool=memcheck` 等工具辅助排查潜在的内存泄漏问题
