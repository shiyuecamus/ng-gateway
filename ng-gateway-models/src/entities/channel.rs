//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.4
//! Modified to support single gateway device credentials storage

use crate::{
    entities::NGEntity,
    enums::common::{CollectionType, EntityType, ReportType, Status},
};
use ng_gateway_sdk::{ChannelModel, ConnectionPolicy};
use sea_orm::{entity::prelude::*, ActiveValue};
#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
#[sea_orm(table_name = "channel")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    /// Driver ID
    pub driver_id: i32,
    /// Name
    pub name: String,
    /// Collection type
    pub collection_type: CollectionType,
    /// Period
    pub period: Option<u32>,
    /// Report type
    pub report_type: ReportType,
    /// Status
    pub status: Status,
    /// Connection policy
    pub connection_policy: ConnectionPolicy,
    /// Driver configuration
    pub driver_config: serde_json::Value,
}

impl From<Model> for ChannelModel {
    fn from(value: Model) -> Self {
        Self {
            id: value.id,
            driver_id: value.driver_id,
            name: value.name,
            collection_type: value.collection_type.into(),
            period: value.period,
            report_type: value.report_type.into(),
            status: value.status.into(),
            connection_policy: value.connection_policy,
            driver_config: value.driver_config,
        }
    }
}

impl NGEntity for Model {
    fn entity_type(&self) -> EntityType {
        EntityType::Channel
    }

    fn id(&self) -> Option<i32> {
        Some(self.id)
    }

    fn status(&self) -> Option<Status> {
        Some(self.status)
    }
}

impl NGEntity for ActiveModel {
    fn entity_type(&self) -> EntityType {
        EntityType::Channel
    }

    fn id(&self) -> Option<i32> {
        self.id.to_owned().take()
    }

    fn status(&self) -> Option<Status> {
        self.status.to_owned().take()
    }
}

impl ActiveModel {
    pub fn merge_with_model(self, mut model: Model) -> Model {
        if let ActiveValue::Set(v) = &self.driver_id {
            model.driver_id = *v;
        }
        if let ActiveValue::Set(v) = &self.name {
            model.name = v.clone();
        }
        if let ActiveValue::Set(v) = &self.collection_type {
            model.collection_type = *v;
        }
        if let ActiveValue::Set(v) = &self.period {
            model.period = *v;
        }
        if let ActiveValue::Set(v) = &self.report_type {
            model.report_type = *v;
        }
        if let ActiveValue::Set(v) = &self.status {
            model.status = *v;
        }
        if let ActiveValue::Set(v) = &self.connection_policy {
            model.connection_policy = v.clone();
        }
        if let ActiveValue::Set(v) = &self.driver_config {
            model.driver_config = v.clone();
        }
        model
    }
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::driver::Entity",
        from = "Column::DriverId",
        to = "super::driver::Column::Id"
    )]
    Driver,
    #[sea_orm(has_many = "super::device::Entity")]
    Device,
}

impl Related<super::device::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Device.def()
    }
}

impl Related<super::driver::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Driver.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
